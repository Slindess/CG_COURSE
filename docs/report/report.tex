\input{gost.tex}

\usepackage{hyperref}

\begin{document}
\setcounter{page}{2}
%\nocite{*}
\renewcommand{\contentsname}{\hfill СОДЕРЖАНИЕ \hfill}
\tableofcontents

\chapter{Аналитическая часть}
\section{Алгоритмы удаления невидимых поверхностей или линий}
Алгоритм Робертса работает в объектном пространстве. В первую очередь он удаляет те грани и линии, которые экранируются самим объектом. После чего, оставшиеся грани выпуклого многранника сравниваются с оставщимися гранями другого выпуклого многогранника. Если же многогранник не является выпуклым, то его придется разбивать на выпуклые, что приводит к дополнительным затратам. 


Метод Z-Буффера работает в пространстве изображений. В нем используется буффер для запоминания глубины каждого видимого пикселя. При обработке нового пикселя его глубина сравнивается с глубиной, записанной в буффере. Основной недостаток -- потребление большого количества памяти. 

В алгоритме, использующем трассировку лучей, из положения камеры испускается луч через каждый пиксель изображения. Каждый луч проверяется на пересечение с объектом 3D сцены. В точке пересечения определяется освещенность поверхности по параметрам. Для рассчета теней испускаются тестовые лучи из точки пересечения к источникам света, если тестовый луч блокируют другие объекты сцены, то точка затеняется по выбранным алгоритмам. 


\section{Отражение}
Прямое освещение объекта равномерным количеством света, взаимодействующего с поверхностью. После того как свет падает на объект, он отражается в зависимости от свойств поверхности объекта, а также угла падения света. Свет, падающий перпендикулярно, создает более яркое освещение (Это явление описывается законом Ламберта). Матовые поверхности (дерево, камень, штукатурка) отражают больше диффузионного света, чем глянцевые, в результате чего они выглядят более мягкими.
При таком отражении положение наблюдателя не имеет значения, так как диффузно отраженный свет рассеивается равномерно по всем направлениям.

Окружающий свет не имеет направления. Его интенсивность определяется войствами материалов поверхностей объектов, а именно их коэффициентами отражения окружающего света.
Так же окружающий свет не отбрасывает тени и не имеет какого-то конкретного источника.
Окружающий свет действует на поверхности объектов независимо от их ориентации. Он добавляет базовый уровень освещенности, чтобы избежать полной темноты на теневых участках. Окружающий свет не требует сложных вычислений, таких как рассчет направления света.
 
Зеркальное отражение создает яркие пятна на объектах, исходя из интенсивности коэффициента зеркального отражения поверхности, а так же угла падения.
Каждый материал имеет свой коэффициент отражения.

\section{Модель освещения}
Модели освещения используются для визуализации световых эффектов, где все рассчеты воспроизводятся на основе законов физики. Главной целью использования модели освещения является вычисления цвета каждого пикселя на основе освещенности объекта, представляемого в этом пикселе.

Локальные модели освещения учитывают световые эффекты, происходящие на объекте, исходя из источников света, находящихся рядом. В таких моделях освещённость пикселей определяется в зависимости от угла падения света, свойств поверхности и её взаимодействия с различными типами отражения (диффузного, зеркального, окружающего). Локальные модели упрощают расчёты, так как не учитывают влияние отражённых лучей от других объектов. На рисунке~\ref{img/local.png} представлено изображение, построенное с использованием локальной моделью освещения.

\imgscheme{local2.png}{Изображение, построенное с использованием локальной моделью освещения}

Глобальная модель освещения учитывает лучи, не только выпущенные из источника, но и отраженные лучи от других объектов. В результате получаются более реалистичные изображения, создание которых требует больших затрат. На рисунке~\ref{img/global.png} представлено изображение, построенное с использованием глобальной модели освещения.

\imgscheme{global2.png}{Изображение, построенное с использованием глобальной модели освещения}

\section{Закраска} Закраска — это процесс определения цвета каждого пикселя на основе его освещенности и свойств поверхности объекта. Существуют различные подходы к закраске, каждый из которых даёт разные результаты в зависимости от того, какие эффекты освещенности учитываются.

Простая закраска (или плоская закраска) — это самый базовый способ закраски объектов. В этом методе для каждого полигона (или поверхности) используется один фиксированный цвет, который зависит от угла падения света на этот полигон.

Закраска Гуро -— это метод, в котором цвета интерполируются между вершинами полигона. Для каждой вершины вычисляется цвет с учётом освещенности (диффузного, зеркального и окружающего света), а затем этот цвет интерполируется по всей поверхности полигона, создавая плавный переход. Закраска Гуро позволяет получить более гладкие и реалистичные изображения по сравнению с простой закраской.

Закраска Фонга -— это более сложный метод, в котором цвет рассчитывается для каждого пикселя, а не только для вершин. В отличие от закраски Гуро, где цвет интерполируется по поверхности, в закраске Фонга используется нормаль каждой точки на поверхности для вычисления угла между нормалью и направлением света. Этот метод позволяет точно моделировать освещенность, учитывая не только диффузное и зеркальное отражение, но и создание бликов на поверхности.

Закраска Фонга подходит для построения реалистичных изображений объектов с гладкими гранями, так как она учитывает нормали в каждой точке поверхности, что позволяет точно моделировать освещенность и плавные переходы между цветами. Однако этот метод плохо подходит для объектов с перпендикулярными гранями (например, кубов или объектов с резкими углами), поскольку в таких случаях интерполяция нормалей может привести к визуальным артефактам и неестественным переходам цвета, из-за чего объекты с резкими углами выглядят неприродно сглаженными.

\section{Представление объектов сцены}
Объекты сцены в 3D--графике часто представляют собой набор полигональных поверхностей, которые используются для аппроксимации сложных форм. Одним из наиболее распространённых типов полигонов является треугольник, который может быть задан тремя вершинами. Именно три вершины необходимо для того, чтобы задать плоскость.

Для того чтобы правильно вычислять освещенность и отображать световые эффекты на поверхности, каждому полигону требуется задвать вектор нормали, который используется для определения угла падения света и позволяет вычислять такие параметры, как диффузное и зеркальное отражение. Так как плоскость имеет две нормали, то необходимо задавать одну из нормалей вручную. 




\section{Сравнение алгоритмов удаления невидимых поверхностей и линий}
В таблице 1.1. представлены результаты сравнения алгоритмов удаления невидимых поверхностей и линий по различным параметрам, где 
$N$ - количество объектов на сцене, $SIZE$ - количество пикселей на экране, P - алгоритм Робертса, Z - алгоритм Z-буффер, T - алгоритм трассировки лучей. 

\begin{table}[h!]
        \small
        \captionsetup{justification=raggedright, singlelinecheck=false, labelsep=endash}
		\caption{Сравнение алгоритмов}
		
		\label{tbl:comparing_algorithms}
		\begin{tabular}{|p{3cm}|p{3cm}|p{3cm}|p{5cm}|}
			 \hline
             Параметр & Р & Z & Т \\
             \hline
             Временная сложность & $O(N^2)$ & $O(SIZE \cdot N)$ & $O(SIZE \cdot N)$ \\
             \hline
             Подготовка данных & Разбиение на выпуклые объекты & $-$ & $-$ \\
             \hline
             Дополнительная Память & $-$ & $+$ & $-$ \\
             \hline
             Преимущества & Простота реализации & Эффективен для 3D сцен & Высокая реалистичность \\
             \hline
             Параллельные вычисления & $-$ & $-$ & $+$ \\ 
             \hline
		\end{tabular}
\end{table}

\section{Генерация горного ландшафта}
Шум Перлина был предложен Кеном Перлином в 1983 году для генерации процедурных текстур и ландшафтов в компьютерной графике. Ландшафт выглядит естественным благодаря наличию в нем случайных элементов: выступов, неровностей. Шум Перлина добавляет эти случайные элементы в создаваемое изображение.

На генерируемой карте выбирается сетка, в узлах которой нужно сгенерировать векторы градиентов функции изменения высоты. Все векторы имеют единичную длину и случайное направление, как показано в формуле~\ref{f1}, где $\theta \in [0, 2\pi]$ — случайный угол.
\begin{equation}
g(x_i) = \cos{\theta} , \quad
g(y_i) = \sin{\theta}
\label{f1}
\end{equation}

В пределах каждого промежутка сетки выбираются точки $(x_p, y_p)$, для которых рассчитывается значение шума.

Для каждой точки внутри ячейки сетки вычисляется смещение относительно ближайших узлов, как показано в формуле~\ref{f2},где $x_{\text{int}}$ и $y_{\text{int}}$ — целочисленные координаты ближайшего узла (например, левого верхнего), а $x_p$ и $y_p$ — координаты точки внутри ячейки, для которой вычисляется шум.
\begin{equation}
u = x_p - x_{\text{int}}, \quad v = y_p - y_{\text{int}}
\label{f2}
\end{equation}


Для каждой из четырех ближайших точек сетки рассчитывается скалярное произведение между градиентом узла и вектором смещения, как показано в формуле~\ref{f3}, где $g_x$ и $g_y$ — компоненты градиента узла, а $d_x$ и $d_y$ — компоненты вектора смещения до точки.
\begin{equation}
\text{dot}(g, d) = g_x \cdot d_x + g_y \cdot d_y
\label{f3}
\end{equation}
где $g_x$ и $g_y$ — компоненты градиента узла, а $d_x$ и $d_y$ — компоненты вектора смещения до точки.

Для получения итогового значения шума в точке используется линейная интерполяция, как показано в формуле~\ref{f4}, где $a$ и $b$ — значения шума из двух ближайших узлов, а $t$ — дробная часть координаты, сглаженная функцией fade.
\begin{equation}
\text{lerp}(a, b, t) = a + t \cdot (b - a)
\label{f4}
\end{equation}


Для плавного перехода между точками применяется функция сглаживания (fade function), как показано в формуле~\ref{f5}.
\begin{equation}
\text{fade}(t) = 6t^5 - 15t^4 + 10t^3
\label{f5}
\end{equation}
Эта функция позволяет избежать резких изменений значений шума между узлами сетки.

На рисунке~\ref{img/wb_simple_perlin.png} показана визуализация шума Перлина. На рисунке~\ref{img/wb_simple_perlin_z.png} показана 3D визуализация шума Перлина.

\imgscheme{wb_simple_perlin.png}{Шум перлина}

\imgscheme{wb_simple_perlin_z.png}{3D визуализация шума}

\section{Формализация задачи}
На рисунке~\ref{img/idef0-1.png} представлена схема задачи построения реалистичного изображения воздушного шара на фоне горного ландшафта в формате idef0.

\imgscheme{idef0-1.png}{Схема задачи построения реалистичного изображения воздушного шара на фоне горного ландшафта в формате idef0}

\section{Вывод}
Можно сделать вывод, что для решения задачи построения реалистичного изображения воздушного шара на фоне горного ландшафта, использование алгоритма трассировки лучей будет обеспечивать большую реалистичность изображения. Также алгоритм трассировки лучей поддается распараллеливанию, в отличие от алгоритма, использующего Z-буффер. Поэтому было решено использовать алгоритм трассировки лучей. 

Ввиду того, что глобальная модель освещения требует больших вычислительных затрат, было решено использовать локальную модель освещения. Для закраски был выбран алгоритм Фонга, так как почти все объекты сцены (воздушный шар, ландшафт) не имеют острых углов и являются гладкими объектами. Для генерации ландшафта был выбран алгоритм, использующий шум Перлина. Для представления объектов было решено использовать полигональную сетку, состоящую из треугольных полигонов, с заданной нормалью.

\chapter{Конструкторская часть}
\section{Диаграмма классов}
На рисунке~\ref{img/uml.png} представленна диаграмма классов для разрабатываемого ПО в формате UML.
\imgscheme{uml.png}{Диаграмма классов в формате UML}

\section{Алгоритм построения изображения}
\imgscheme[150mm]{idef0-2.png}{Схема}





\renewcommand\bibname{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
\bibliographystyle{biblio.bst}
\bibliography{source.bib}
\addcontentsline{toc}{chapter}{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
\end{document}

