\input{gost.tex}

\usepackage{hyperref}

\begin{document}
\setcounter{page}{2}
%\nocite{*}
\renewcommand{\contentsname}{\hfill СОДЕРЖАНИЕ \hfill}
\tableofcontents

\chaptercentered{ВВЕДЕНИЕ}
Современные методы компьютерной графики находят применение в самых разных областях, от разработки видеоигр до научной визуализации сложных физических процессов. Одной из ключевых задач является создание фотореалистичных изображений, передающих естественное представление объекта. В рамках данной работы рассматривается визуализация воздушного шара на фоне горного ландшафта.

Визуализация такой сцены требует учета множества аспектов: генерации сложной поверхности горного ландшафта, корректного вычисления освещения, теней, наложения текстур.

Цель работы заключается в разработке программной визуализации сцены с использованием современных методов компьютерной графики, обеспечивающей качественное изображение сцены с учетом световых эффектов и особенностей поверхностей объектов. 

Для достижения поставленной цели планируется решить следующие задачи:
\begin{enumerate}
\item необходимо разработать программу для визуализации горного ландшафта с высоты полета воздушного шара;
\item Ландшафт генерировать процедурно;
\item В качестве неподвижного источника освещения должно выступать солнце;
\item Требуется провести исследование времени работы программы от количества потоков.
\end{enumerate}

\chapter{Аналитическая часть}
\section{Алгоритмы удаления невидимых поверхностей или линий}
Для корректного отображения объектов необходимо обеспечить удаление невидимых поверхностей и линий. Поверхности могут экранироваться как самим объектом, так и другими объектами.

Алгоритм Робертса работает в объектном пространстве. В первую очередь он удаляет те грани и линии, которые экранируются самим объектом. После чего оставшиеся грани выпуклого многранника сравниваются с оставщимися гранями другого выпуклого многогранника. Если же многогранник не является выпуклым, то его придется разбивать на выпуклые, что приводит к дополнительным затратам. 


Алгоритм, использующий Z-буффер, работает в пространстве изображений. В нем используется буффер для запоминания глубины каждого видимого пикселя. При обработке нового пикселя его глубина сравнивается с глубиной, записанной в буффере. Основной недостаток -- потребление большого количества памяти, требемой для самого Z-буффера. На рисунке \ref{img/z1.png} представленно полученное в процессе рендеринга с применением алгоритма, использующего Z-буффер, 3D изображение. На рисунке \ref{img/z2.png} представленна визуализация Z-буффера, хранящеего Z-координаты 3D объектов сцены. 

\imgscheme{z1.png}{Визуализация 3D сцены}

\imgscheme{z2.png}{Визуализация Z-буффера, представляющего сцену}

В алгоритме, использующем трассировку лучей, из положения камеры испускается луч через каждый пиксель изображения. Каждый луч проверяется на пересечение с объектом 3D сцены. В точке пересечения определяется освещенность поверхности по параметрам. Для рассчета теней испускаются тестовые лучи из точки пересечения к источникам света, если тестовый луч блокируют другие объекты сцены, то точка затеняется по выбранному метод затенения. На рисунке \ref{img/rtx1.png} представлено изображение, полученное с помощью алгоритма, использующего Z-буффер. На рисунке \ref{img/rtx2.png} представлено изображение, полученное с помощью алгоритма, использующего трассировку лучей. В алгоритме, использющем трассировку лучей не требуется вычислять проекции точек объекта на экран, не требуется проводить отсечение объектов, находящихся вне зоны видимости камеры \cite{gabriel}.

\imgscheme{rtx1.png}{Изображение, полученное c помощью алгоритма, использующего Z-буффер}
\imgscheme{rtx2.png}{Изображение, полученное c помощью алгоритма, использующего трассировку лучей}


\section{Отражение}
Прямое освещение объекта происходит равномерным количеством света, взаимодействующего с поверхностью. После того как свет падает на объект, он отражается в зависимости от свойств поверхности объекта, а также угла падения света. Свет, падающий перпендикулярно, создает более яркое освещение. Матовые поверхности (дерево, камень, штукатурка) отражают больше диффузионного света, чем глянцевые, в результате чего они выглядят более мягкими.
При таком отражении положение наблюдателя не имеет значения, так как диффузно отраженный свет рассеивается равномерно по всем направлениям.

Окружающий свет не имеет направления. Его интенсивность определяется cвойствами материалов поверхностей объектов, а именно их коэффициентами отражения окружающего света.
Так же окружающий свет не отбрасывает тени и не имеет какого-то конкретного источника.
Окружающий свет действует на поверхности объектов независимо от их ориентации. Он добавляет базовый уровень освещенности, чтобы избежать полной темноты на теневых участках. Окружающий свет не требует сложных вычислений, таких как рассчет направления света.
 
Зеркальное отражение создает яркие пятна на объектах, исходя из интенсивности коэффициента зеркального отражения поверхности, а так же угла падения.
Каждый материал имеет свой коэффициент отражения.

\section{Модель освещения}
Модели освещения используются для визуализации световых эффектов, где все рассчеты воспроизводятся на основе законов физики. Главной целью использования модели освещения является вычисления цвета каждого пикселя на основе освещенности объекта, представляемого в этом пикселе.

Локальные модели освещения учитывают световые эффекты, происходящие на объекте, исходя из источников света, находящихся рядом. В таких моделях освещённость пикселей определяется в зависимости от угла падения света, свойств поверхности и её взаимодействия с различными типами отражения (диффузного, зеркального, окружающего). Локальные модели упрощают расчёты, так как не учитывают влияние отражённых лучей от других объектов. На рисунке~\ref{img/local2.png} представлено изображение, построенное с использованием локальной модели освещения.

\imgscheme{local2.png}{Изображение, построенное с использованием локальной модели освещения}

Глобальная модель освещения учитывает не только лучи, выпущенные из источника, но и отраженные лучи от других объектов. В результате получаются более реалистичные изображения, создание которых требует больших затрат \cite{pharr}. На рисунке~\ref{img/global2.png} представлено изображение, построенное с использованием глобальной модели освещения.

\imgscheme{global2.png}{Изображение, построенное с использованием глобальной модели освещения}

\section{Закраска} Закраска -- это процесс определения цвета каждого пикселя на основе его освещенности и свойств поверхности объекта. Существуют различные подходы к закраске, каждый из которых даёт разные результаты в зависимости от того, какие эффекты освещенности учитываются.

Простая закраска (или плоская закраска) -- это самый базовый способ закраски объектов. В этом методе для каждого полигона (или поверхности) используется один фиксированный цвет, который зависит от угла падения света на этот полигон.

Закраска Гуро -- это метод, в котором цвета интерполируются между вершинами полигона. Для каждой вершины вычисляется цвет с учётом освещенности (диффузного, зеркального и окружающего света), а затем этот цвет интерполируется по всей поверхности полигона, создавая плавный переход. Закраска Гуро позволяет получить более гладкие и реалистичные изображения по сравнению с простой закраской.

Закраска Фонга -— это более сложный метод, в котором цвет рассчитывается для каждого пикселя, а не только для вершин. В отличие от закраски Гуро, где цвет интерполируется по поверхности, в закраске Фонга используется нормаль к каждой точке на поверхности для вычисления угла между нормалью и направлением света. Этот метод позволяет точно моделировать освещенность, учитывая не только диффузное и зеркальное отражение, но и создание бликов на поверхности.

Закраска Фонга подходит для построения реалистичных изображений объектов с гладкими гранями, так как она учитывает нормали в каждой точке поверхности, что позволяет точно моделировать освещенность и плавные переходы между цветами. Однако этот метод плохо подходит для объектов с перпендикулярными гранями (например, кубов или объектов с резкими углами), поскольку в таких случаях интерполяция нормалей может привести к визуальным артефактам и неестественным переходам цвета, из-за чего объекты с резкими углами выглядят неприродно сглаженными.

\section{Представление объектов сцены}
Объекты сцены в 3D--графике часто представляют собой набор полигональных поверхностей, которые используются для аппроксимации сложных форм. Одним из наиболее распространённых типов полигонов является треугольник, который может быть задан тремя вершинами. Именно три вершины необходимо для того, чтобы задать плоскость.

Для того чтобы правильно вычислять освещенность и отображать световые эффекты на поверхности, каждому полигону требуется задвать вектор нормали, который используется для определения угла падения света и позволяет вычислять такие параметры, как диффузное и зеркальное отражение. Так как плоскость имеет две нормали, то необходимо задавать одну из нормалей вручную. 

\section{Сравнение алгоритмов удаления невидимых поверхностей и линий}
В таблице 1.1. представлены результаты сравнения алгоритмов удаления невидимых поверхностей и линий по различным параметрам, где 
$N$ - количество объектов на сцене, $SIZE$ - количество пикселей на экране, P - алгоритм Робертса, Z - алгоритм Z-буффер, T - алгоритм трассировки лучей. 

\begin{table}[h!]
        \small
        \captionsetup{justification=raggedright, singlelinecheck=false, labelsep=endash}
		\caption{Сравнение алгоритмов}
		
		\label{tbl:comparing_algorithms}
		\begin{tabular}{|p{3cm}|p{3cm}|p{3cm}|p{5cm}|}
			 \hline
             Параметр & Р & Z & Т \\
             \hline
             Временная сложность & $O(N^2)$ & $O(SIZE \cdot N)$ & $O(SIZE \cdot N)$ \\
             \hline
             Подготовка данных & Разбиение на выпуклые объекты & $-$ & $-$ \\
             \hline
             Дополнительная Память & $-$ & $+$ & $-$ \\
             \hline
             Преимущества & Простота реализации & Эффективен для 3D сцен & Высокая реалистичность \\
             \hline
             Параллельные вычисления & $-$ & $-$ & $+$ \\ 
             \hline
		\end{tabular}
\end{table}

\section{Генерация горного ландшафта}
Шум Перлина был предложен Кеном Перлином в 1983 году для генерации процедурных текстур и ландшафтов в компьютерной графике. Ландшафт выглядит естественным благодаря наличию в нем случайных элементов: выступов, неровностей. Шум Перлина добавляет эти случайные элементы в создаваемое изображение.

На генерируемой карте выбирается сетка, в узлах которой нужно сгенерировать векторы градиентов функции изменения высоты. Все векторы имеют единичную длину и случайное направление, как показано в формуле~\ref{f1} \cite{real_time}, где $\theta \in [0, 2\pi]$ — случайный угол.
\begin{equation}
g(x_i) = \cos{\theta} , \quad
g(y_i) = \sin{\theta}
\label{f1}
\end{equation}

В пределах каждого промежутка сетки выбираются точки $(x_p, y_p)$, для которых рассчитывается значение шума.

Для каждой точки внутри ячейки сетки вычисляется смещение относительно ближайших узлов, как показано в формуле~\ref{f2} \cite{real_time},где $x_{\text{int}}$ и $y_{\text{int}}$ — целочисленные координаты ближайшего узла (например, левого верхнего), а $x_p$ и $y_p$ — координаты точки внутри ячейки, для которой вычисляется шум.
\begin{equation}
u = x_p - x_{\text{int}}, \quad v = y_p - y_{\text{int}}
\label{f2}
\end{equation}


Для каждой из четырех ближайших точек сетки рассчитывается скалярное произведение между градиентом узла и вектором смещения, как показано в формуле~\ref{f3} \cite{real_time}, где $g_x$ и $g_y$ — компоненты градиента узла, а $d_x$ и $d_y$ — компоненты вектора смещения до точки.
\begin{equation}
\text{dot}(g, d) = g_x \cdot d_x + g_y \cdot d_y
\label{f3}
\end{equation}
где $g_x$ и $g_y$ — компоненты градиента узла, а $d_x$ и $d_y$ — компоненты вектора смещения до точки.

Для получения итогового значения шума в точке используется линейная интерполяция, как показано в формуле~\ref{f4} \cite{real_time}, где $a$ и $b$ — значения шума из двух ближайших узлов, а $t$ — дробная часть координаты, сглаженная функцией fade.
\begin{equation}
\text{lerp}(a, b, t) = a + t \cdot (b - a)
\label{f4}
\end{equation}


Для плавного перехода между точками применяется функция сглаживания (fade function), как показано в формуле~\ref{f5} \cite{real_time}.
\begin{equation}
\text{fade}(t) = 6t^5 - 15t^4 + 10t^3
\label{f5}
\end{equation}
Эта функция позволяет избежать резких изменений значений шума между узлами сетки.

На рисунке~\ref{img/wb_simple_perlin.png} показана визуализация шума Перлина. На рисунке~\ref{img/wb_simple_perlin_z.png} показана 3D визуализация шума Перлина.

\imgscheme{wb_simple_perlin.png}{Шум перлина}

\imgscheme{wb_simple_perlin_z.png}{3D визуализация шума}

\section{Формализация задачи}
На рисунке~\ref{img/idef0-1.png} представлена схема задачи построения реалистичного изображения воздушного шара на фоне горного ландшафта в формате idef0.

\imgscheme{idef0-1.png}{Схема задачи построения реалистичного изображения воздушного шара на фоне горного ландшафта в формате idef0}

\section{Вывод}
Можно сделать вывод, что для решения задачи построения реалистичного изображения воздушного шара на фоне горного ландшафта, использование алгоритма трассировки лучей будет обеспечивать большую реалистичность изображения. Также алгоритм трассировки лучей поддается распараллеливанию, в отличие от алгоритма, использующего Z-буффер. Поэтому было решено использовать алгоритм трассировки лучей. 

Ввиду того, что глобальная модель освещения требует больших вычислительных затрат, было решено использовать локальную модель освещения. Для закраски был выбран алгоритм Фонга, так как почти все объекты сцены (воздушный шар, ландшафт) не имеют острых углов и являются гладкими объектами. Для генерации ландшафта был выбран алгоритм, использующий шум Перлина. Для представления объектов было решено использовать полигональную сетку, состоящую из треугольных полигонов с заданной нормалью.

\chapter{Конструкторская часть}
\section{Алгоритм построения изображения}
На рисунке~\ref{img/idef0-2.png} изображено представление рендера изображения ввиде диаграммы idef0.
\imgscheme[150mm]{idef0-2.png}{Схема рендера изображения}

На рисунке~\ref{img/alg-1.png} изображено представление алгоритма, использующего трассировку лучей, в виде блок-схемы. На рисунке~\ref{img/alg-2.png} изображено представление алгоритма, осуществляющего закраску Фонга, в виде блок-схемы.

\imgscheme{alg-1.png}{Схема}

\imgscheme{alg-2.png}{Схема}

\section{Математические основы алгоритмов}
Алгоритм трассировки лучей основан на поиске пересечение луча с полигоном. Для этого используется параметрическое представление луча и треугольника.
Параметрическое уравнение луча представлено в формуле~\ref{f11} \cite{sherley}, где $O$ - начальная точка луча, $D$ - направление луча.

\begin{equation}
P(t) = O + t \cdot D
\label{f11}
\end{equation}

Параметрическое уравнение треугольника представлено в формуле~\ref{f12} \cite{sherley}, где $V_{0}$, $V_{1}$, $V_{2}$  - вершины треугольника.

\begin{equation}
P(u, v) = (1 - u - v) \cdot V_{0} + u \cdot V_{1} + v \cdot V_{2}
\label{f12}
\end{equation}

Для нахождения пересечения луча с треугольником необходимо решить систему уравнений, которая выражает пересечение двух параметрических уравнений: луча и треугольника. Для этого используется метод матричного детерминанта для вычисления коэффициентов \( t \), \( \gamma \) и \( \beta \), которые определяют положение точки пересечения на луче и в пределах треугольника.

Для вычисления пересечения вычисляется детерминант матрицы, которая зависит от разности координат вершин треугольника и направлений луча. Если детерминант слишком мал, то пересечения нет, так как луч и плоскость треугольника не пересекаются.

Детерминант $A$ вычисляется по формуле~\ref{f13} \cite{sherley}, где:
\begin{enumerate}
    \item \(a = v_0[X] - v_1[X]\),
    \item \(b = v_0[Y] - v_1[Y]\),
    \item \(c = v_0[Z] - v_1[Z]\),
    \item \(d = v_0[X] - v_2[X]\),
    \item \(e = v_0[Y] - v_2[Y]\),
    \item \(f = v_0[Z] - v_2[Z]\),
    \item \(g = \text{rayDir}[X]\),
    \item \(h = \text{rayDir}[Y]\),
    \item \(i = \text{rayDir}[Z]\).
\end{enumerate}

\begin{equation}
\text{det}(A) = 
\begin{vmatrix}
a & b & c \\
d & e & f \\
g & h & i
\end{vmatrix} = a(ei - fh) - b(di - fg) + c(dh - eg)
\label{f13}
\end{equation}

Если детерминант матрицы \(\text{det}(A)\) не равен нулю, то вычисляется параметр \(t\), который определяет расстояние от начала луча до точки пересечения по формуле~\ref{f14} \cite{sherley}, где:
\begin{enumerate}
    \item \(j = v_0[X] - \text{rayOrigin}[X]\),
    \item \(k = v_0[Y] - \text{rayOrigin}[Y]\),
    \item \(l = v_0[Z] - \text{rayOrigin}[Z]\).
\end{enumerate}

\begin{equation}
t = - \frac{(f \cdot (a \cdot k - j \cdot b) + e \cdot (j \cdot c - a \cdot l) + d \cdot (b \cdot l - k \cdot c))}{\text{det}(A)}
\label{f14}
\end{equation}

\section{Вывод}
В данном разделе были представлены схемы алгоритмов рендеринга изображения и математические основы алгоритма поиска пересечения луча с полигоном.

\chapter{Технологическая часть}
\section{Средства реализации}
В качестве языка программирования для реализации программного
обеспечения был выбран язык программирования \texttt{C++} \cite{cpp}, так как он позволяет реализовать все выбранные алгоритмы и имеет поддержку нативных потоков.

Для визуализации изображения и реализации интерфейса был выбран фреймворк \texttt{QT5} \cite{qt5} так как в нем есть поддержка вывода изображений.

\section{Диаграмма классов}
На рисунке~\ref{img/uml.png} представленна диаграмма классов для разрабатываемого ПО в формате UML.
\imgscheme{uml.png}{Диаграмма классов в формате UML}

\section{Пример работы программы}
На рисунках \ref{img/8.png}, \ref{img/2.png}, \ref{img/3.png}, \ref{img/4.png}, \ref{img/5.png}, \ref{img/6.png}, \ref{img/7.png} представлены примеры работы программы.
\imgscheme{8.png}{Интерфейс программы}

\imgscheme{2.png}{Пример созданного изображения снежного ландшафта с видом из корзины}

\imgscheme{3.png}{Пример созданного изображения тропического ландшафта}
\imgscheme{4.png}{Пример созданного изображения тропического ландшафта с видом из корзины}

\imgscheme{5.png}{Пример созданного изображения песчаного ландшафта}
\imgscheme{6.png}{Пример созданного изображения песчаного ландшафта с видом из корзины}

\imgscheme{7.png}{Пример созданного изображения песчаного ландшафта без воздушного шара}

\chapter{Исследовательская часть}
В данной части описано проведённое исследование и его результаты,
а так же технические характеристики устройства, на котором проводились
замеры.

\section{Технические характеристики}
Технические характеристики устройства, на котором выполнялись
замеры:
\begin{enumerate}
\item операционная система Ubuntu 22.04.045 LTS \cite{Ubuntu};
\item процессор Intel Core i5-10400F 2.9 ГГц \cite{Intel};
\item 16 ГБ оперативной памяти.
\end{enumerate}

\section{Зависимость времени создания изображения от количества потоков}
Для проведения замеров времени использовалась функция \texttt{std::chrono} \cite{Chrono}.
В таблице \ref{tbl:execution_time_vs_threads} представлена зависимость времени выполнения программы от количества используемых потоков. Для каждого значения количества потоков указано время выполнения программы в секундах.

\begin{table}[h!]
    \small
    \captionsetup{justification=raggedright, singlelinecheck=false, labelsep=endash}
    \caption{Зависимость времени выполнения от количества потоков}
    \label{tbl:execution_time_vs_threads}
    \begin{tabular}{|p{3cm}|p{5cm}|}
        \hline
        Количество потоков & Время выполнения (секунды) \\
        \hline
        1 & 17.8488 \\
        2 & 13.6123 \\
        3 & 10.2385 \\
        4 & 8.41588 \\
        5 & 7.18214 \\
        6 & 6.24993 \\
        7 & 5.488 \\
        8 & 5.1341 \\
        9 & 4.8422 \\
        10 & 4.5506 \\
        15 & 4.05306 \\
        20 & 3.95047 \\
        25 & 3.8543 \\
        30 & 3.78371 \\
        31 & 3.7 \\
        32 & 3.5786 \\
        33 & 3.96616 \\
        34 & 4.24772 \\
        35 & 4.89 \\
        40 & 4.959 \\
        45 & 5.24695 \\
        \hline
    \end{tabular}
\end{table}

На рисунке \ref{img/research.png} представлен график зависимости времени выполнения программы от количества потоков.
\imgscheme{research.png}{График зависимости времени выполнения программы от количества потоков}

\section{Вывод}
Из этого раздела можно сделать вывод, что с увеличением количества потоков время выполнения программы сначала значительно сокращается, что связано с эффективным использованием многопоточности. Однако, начиная с определенного количества потоков (около 32), время выполнения перестает уменьшаться, а при дальнейшем увеличении даже возрастает. Это может быть связано с накладными расходами на синхронизацию потоков, ограничениями аппаратного обеспечения или снижением эффективности при распределении нагрузки между потоками.

\chaptercentered{ЗАКЛЮЧЕНИЕ}

В рамках данной работы была решена задача визуализации сцены, включающей воздушный шар и горный ландшафт, с использованием современных методов компьютерной графики.

Для достижения поставленной цели была разработана программа для визуализации горного ландшафта с высоты полета воздушного шара. Также было проведено исследование зависимости времени работы программы от количества потоков, что позволило выявить возможности оптимизации вычислений.

Полученные результаты демонстрируют, что предложенные подходы и алгоритмы успешно справляются с задачей визуализации горного ландшафта и воздушного шара. Выполненный анализ времени работы программы подтверждает эффективность использования параллельных вычислений для повышения производительности.

\renewcommand\bibname{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
\bibliographystyle{biblio.bst}
\bibliography{source.bib}
\addcontentsline{toc}{chapter}{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
\end{document}
%z.n.rusakova@mail.ru
